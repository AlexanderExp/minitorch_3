# Подробные примеры работы `tensor_map`

* aligned (shape и strides совпадают у `out` и `in`)
* not aligned из-за **broadcast** (формы разные)
* not aligned из-за **среза** (формы равны, strides разные)

Во всех примерах возьмём `fn(x) = x + 100` для наглядности.

---

## 1) aligned: обе матрицы C-contiguous одинаковой формы

```
in_shape  = (2, 3)
in_strides= (3, 1)      # C-порядок
in_storage= [ 0, 1, 2,
              3, 4, 5 ]

out_shape  = (2, 3)
out_strides= (3, 1)     # то же самое
out_storage= [?, ?, ?, ?, ?, ?]
```

`size = 6`. Для каждой итерации:

| ord\_ | out\_index (расчёт rem%/rem//=) | pos = Σ idx\[i]\*stride\[i] | чтение `in[pos]` | запись `out[pos] = in[pos]+100` |
| ----- | ------------------------------- | --------------------------- | ---------------- | ------------------------------- |
| 0     | (0,0)                           | 0*3 + 0*1 = **0**           | 0                | 100                             |
| 1     | (0,1)                           | 0*3 + 1*1 = **1**           | 1                | 101                             |
| 2     | (0,2)                           | **2**                       | 2                | 102                             |
| 3     | (1,0)                           | 1\*3 + 0 = **3**            | 3                | 103                             |
| 4     | (1,1)                           | **4**                       | 4                | 104                             |
| 5     | (1,2)                           | **5**                       | 5                | 105                             |

Поскольку **aligned=True**, адрес во входе и выходе один и тот же `pos`: читаем `in[pos]`, пишем в `out[pos]`.

Итог `out_storage = [100,101,102,103,104,105]`.

---

## 2) not aligned: **broadcast** по первой оси

`in` имеет форму `(1, 3)` и «растягивается» до `(2, 3)`.

```
in_shape   = (1, 3)
in_strides = (3, 1)     # обычные для (1,3)
in_storage = [10, 20, 30]

out_shape   = (2, 3)
out_strides = (3, 1)    # обычные для (2,3)
out_storage = [?, ?, ?, ?, ?, ?]
```

Алгоритм делает:

1. `ord_ → out_index` (как раньше),
2. `broadcast_index(out_index, out_shape, in_shape, in_index)`:

   * если `in_shape[d] == 1`, то `in_index[d] = 0`,
   * иначе `in_index[d] = out_index[d]`.

Посмотрим итерации:

| ord\_ | out\_index | out\_pos (3,1) | in\_index (broadcast)     | in\_pos (3,1) | чтение `in[in_pos]` | запись `out[out_pos]` |
| ----- | ---------- | -------------- | ------------------------- | ------------- | ------------------- | --------------------- |
| 0     | (0,0)      | 0              | (0,0)                     | 0             | 10                  | 110                   |
| 1     | (0,1)      | 1              | (0,1)                     | 1             | 20                  | 120                   |
| 2     | (0,2)      | 2              | (0,2)                     | 2             | 30                  | 130                   |
| 3     | (1,0)      | 3              | (0,0) ← ось 0 «схлопнута» | 0             | 10                  | 110                   |
| 4     | (1,1)      | 4              | (0,1)                     | 1             | 20                  | 120                   |
| 5     | (1,2)      | 5              | (0,2)                     | 2             | 30                  | 130                   |

Здесь **out\_pos ≠ in\_pos** в общем смысле (у них просто разные формы). Первая ось входа всегда 0, поэтому элементы `[10,20,30]` повторяются на обе строки выхода.

Итог `out_storage = [110,120,130,110,120,130]`.

---

## 3) not aligned: одинаковая форма, но **разные strides** (срез)

Возьмём базовый буфер `(2,4)` C-contiguous и срежем каждую вторую колонку: `a = base[:, ::2]`.

```
base_shape   = (2, 4)
base_strides = (4, 1)
base_storage = [  0,  1,  2,  3,
                   4,  5,  6,  7 ]

in = base[:, ::2]
in_shape   = (2, 2)
in_strides = (4, 2)   # шаг по колонке удвоился из-за ::2
in_storage = тот же буфер base_storage

out_shape   = (2, 2)
out_strides = (2, 1)  # новый буфер под результат — C-contiguous
out_storage = [?, ?, ?, ?]
```

Ветка будет «общая» (aligned=False), т.к. strides не совпадают. Broadcasting тут не меняет индекс (формы равны), так что `in_index = out_index`. Но **адреса** разные из-за различающихся strides.

Итерации:

| ord\_ | out\_index | out\_pos (2,1) | in\_index | in\_pos (4,2) | чтение из base\_storage\[in\_pos] | запись |
| ----- | ---------- | -------------- | --------- | ------------- | --------------------------------- | ------ |
| 0     | (0,0)      | 0              | (0,0)     | 0*4 + 0*2 = 0 | 0                                 | 100    |
| 1     | (0,1)      | 1              | (0,1)     | 0*4 + 1*2 = 2 | 2                                 | 102    |
| 2     | (1,0)      | 2              | (1,0)     | 1*4 + 0*2 = 4 | 4                                 | 104    |
| 3     | (1,1)      | 3              | (1,1)     | 1*4 + 1*2 = 6 | 6                                 | 106    |

Заметь: физически мы читаем элементы `0,2,4,6` исходного буфера (то есть ровно «каждую вторую колонку»), а кладём их **плотно** в новый `out`-буфер.

Итог `out_storage = [100,102,104,106]`.

---

### Что здесь важно увидеть

* **aligned**: один расчёт `pos` → одна операция чтения+записи по одному и тому же адресу. Самый дешёвый путь.
* **broadcast**: `in_index` отличается от `out_index` там, где размер входа равен 1 — разные `in_pos` и `out_pos`.
* **разные strides**: даже при одинаковых формах `pos` у входа и выхода различаются — именно поэтому **нельзя** подставлять `ord_` вместо `pos`, и нельзя «копировать» по одному и тому же индексу без пересчёта по страйдам.
